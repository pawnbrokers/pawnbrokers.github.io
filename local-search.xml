<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>oss工作原理</title>
    <link href="/2024/02/20/oss%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2024/02/20/oss%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-OSS工作原理"><a href="#1-OSS工作原理" class="headerlink" title="1. OSS工作原理"></a>1. OSS工作原理</h1><p>OSS（Object Storage Service）是阿里云提供的一种可扩展的对象存储服务。它的工作原理可以总结如下：</p><ol><li><strong>数据模型</strong>：OSS是基于对象的存储服务，每个对象都有唯一的标识符（Object Key）和数据内容。对象可以是任意类型的文件，如文本文件、图片、视频等。</li><li><strong>存储桶</strong>：OSS的存储单位是存储桶（Bucket），每个存储桶具有全局唯一的名称。用户可以在OSS上创建多个存储桶，并将对象存储在这些存储桶中。存储桶还具有访问权限控制和存储区域（Region）等属性。</li><li><strong>API和SDK</strong>：OSS提供了丰富的API和SDK，使用户可以通过编程接口进行对象的上传、下载、删除等操作。用户可以使用各种编程语言（如Java、Python、Go等）来与OSS进行交互。</li><li><strong>数据上传</strong>：用户可以将数据通过API或SDK上传到指定的存储桶中。在上传过程中，OSS会将数据切分成固定大小的数据块，并采用分布式存储的方式将这些数据块分散存储在多个物理节点上。OSS还提供了断点续传的功能，可以支持大文件的上传。</li><li><strong>数据下载</strong>：用户可以通过API或SDK从存储桶中下载对象。OSS会根据用户的请求，将对象的数据块并行地从多个节点获取，并将数据块拼接成完整的对象返回给用户。</li><li><strong>数据访问权限</strong>：OSS支持细粒度的数据访问权限控制。用户可以通过设置存储桶和对象的访问权限，控制谁可以读取和写入数据。</li><li><strong>数据安全</strong>：OSS提供了多种数据安全机制，包括数据加密、访问日志记录、防盗链等功能，以保护数据的安全性和隐私性。</li><li><strong>数据管理</strong>：OSS还提供了丰富的数据管理功能，如对象的复制、归档、生命周期管理等。用户可以根据需要对存储的对象进行管理和操作。</li></ol><p>总体而言，OSS的工作原理是基于分布式存储架构的对象存储服务。通过将对象切分、分布和冗余存储，OSS实现了高可用性、高可靠性和高性能的数据存储和访问能力。</p><h1 id="2-OSS为什么可以实现快速读取"><a href="#2-OSS为什么可以实现快速读取" class="headerlink" title="2. OSS为什么可以实现快速读取"></a>2. OSS为什么可以实现快速读取</h1><p>OSS的快速读取能力主要归功于以下几个方面的工作原理：</p><ol><li><strong>分布式架构</strong>：OSS采用分布式架构，将数据在多个存储节点上进行分散存储。这种架构允许数据并行读取，从而提高了读取速度。同时，OSS还根据用户的地理位置和网络状况选择最近的节点进行读取，减少网络延迟，提高响应速度。</li><li><strong>数据冗余备份</strong>：OSS在后台进行数据冗余备份，将数据存储在多个物理设备上，以防止数据丢失。这种冗余备份的方式不仅提高了数据的可靠性，还允许同时从多个设备读取数据，以提高读取性能。</li><li><strong>数据分块和分段下载</strong>：当读取大文件时，OSS将文件分成多个块或段，并允许并行下载这些块或段。客户端可以同时从多个节点或线程下载数据，从而实现快速读取。</li><li><strong>缓存机制</strong>：OSS提供了内置的缓存机制，可以缓存经常访问的数据。当有读取请求到达时，OSS首先检查缓存是否有相应的数据，如果有，则直接返回缓存数据，避免了对底层存储系统的访问，提高了读取速度。</li><li><strong>智能优化</strong>：OSS还通过技术手段对数据进行智能优化，包括数据压缩、网络传输优化等。这些优化措施能够减少数据传输量和传输时间，提高读取效率。</li></ol><p>综上所述，OSS的快速读取能力得益于其分布式架构、数据冗余备份、数据分块和分段下载、缓存机制以及智能优化等工作原理的综合作用。这些机制和优化措施使得OSS能够高效地处理读取请求，并提供快速的数据访问速度。</p><h1 id="3-OSS如何实现数据的并行读取"><a href="#3-OSS如何实现数据的并行读取" class="headerlink" title="3. OSS如何实现数据的并行读取"></a>3. OSS如何实现数据的并行读取</h1><p>OSS的分布式架构通过以下方式实现数据的并行读取：</p><ol><li><strong>数据切片和分布</strong>：当用户上传数据到OSS时，OSS会将数据切片成多个固定大小的块，并将这些块分散存储在不同的存储节点上。这样做可以将数据分布在多个节点上，实现数据的并行读取。</li><li><strong>数据位置的映射</strong>：OSS会维护一个数据位置的映射表，记录每个数据块存储的节点和位置信息。当读取请求到达时，OSS根据请求的数据块标识符查找映射表，确定数据块所在的节点，然后并行从多个节点读取数据。</li><li><strong>数据的多副本备份</strong>：为了提高数据的可靠性和读取性能，OSS会对数据进行多副本备份，将数据存储在多个物理节点上。当进行数据读取时，可以从多个副本中选择一个最近的节点进行读取，以减少网络延迟和提高读取速度。</li><li><strong>负载均衡和调度</strong>：OSS会进行负载均衡和调度，根据节点的负载情况和网络状况，自动选择最优的节点进行数据读取。这样可以充分利用集群中各个节点的计算和存储资源，提高并行读取的效率。</li></ol><p>通过以上机制，OSS实现了数据的切片和分布、数据位置的映射、多副本备份以及负载均衡和调度等功能，从而实现了数据的并行读取。这样的分布式架构能够充分利用集群中的资源，提高读取性能和吞吐量，满足用户对快速读取的需求。</p><h1 id="4-OSS的数据切片和分布是如何保证数据的完整性和一致性的"><a href="#4-OSS的数据切片和分布是如何保证数据的完整性和一致性的" class="headerlink" title="4. OSS的数据切片和分布是如何保证数据的完整性和一致性的"></a>4. OSS的数据切片和分布是如何保证数据的完整性和一致性的</h1><p>OSS通过以下方式来保证数据的完整性和一致性：</p><ol><li><strong>冗余备份</strong>：OSS采用多副本备份策略，将数据存储在多个物理节点上。每个数据块都会被复制到多个节点，通常是三个或更多副本。这样即使某个节点或磁盘发生故障，仍然可以从其他副本中恢复数据，确保数据的完整性。</li><li><strong>数据校验和</strong>：OSS会为每个数据块计算校验和，并将校验和信息存储在元数据中。在读取数据时，OSS会验证读取的数据块的校验和是否与元数据中记录的一致，以确保数据的完整性。</li><li><strong>一致性协议</strong>：OSS使用一致性协议来保证数据的一致性。一致性协议确保在数据写入完成之前，所有的副本都会被更新，从而保证了数据在不同节点之间的一致性。</li><li><strong>数据修复</strong>：如果在读取数据时发现某个数据块损坏或丢失，OSS会自动进行数据修复。它会使用其他副本的数据来恢复丢失或损坏的数据块，并更新副本以确保数据的完整性。</li><li><strong>写入确认机制</strong>：OSS在数据写入时采用写入确认机制，确保数据成功写入并在多个副本上复制。只有当所有的副本都成功写入后，写入操作才会返回成功，从而确保数据的一致性和完整性。</li></ol><p>综上所述，OSS通过冗余备份、数据校验和、一致性协议、数据修复以及写入确认机制等方式来保证数据的完整性和一致性。这些机制确保了数据在存储和读取过程中的可靠性，从而提供了高度可靠的数据存储服务。</p><h1 id="5-数据校验如何实现？"><a href="#5-数据校验如何实现？" class="headerlink" title="5. 数据校验如何实现？"></a>5. 数据校验如何实现？</h1><p>OSS为每个数据块计算校验和的实现方式如下：</p><ol><li><strong>数据切片</strong>：在上传数据到OSS时，数据会被切分成固定大小的数据块。</li><li><strong>校验和算法</strong>：OSS使用一种校验和算法（通常是MD5或CRC32）来计算数据块的校验和。这些算法能够将数据块的内容转换为唯一的校验和值。</li><li><strong>校验和计算</strong>：在上传数据块到OSS时，OSS会对每个数据块进行校验和计算。它会读取数据块的内容，并使用选定的校验和算法对内容进行计算，生成唯一的校验和值。</li><li><strong>校验和存储</strong>：OSS会将校验和值作为元数据与数据块一起存储。元数据是存储在OSS中的对象的附加信息，在校验和的情况下，它存储了数据块的校验和值。</li><li><strong>校验和验证</strong>：在读取数据块时，OSS会同时读取保存的校验和值。一旦数据块被读取完毕，OSS会再次对读取的数据块进行校验和计算，得到一个新的校验和值。</li><li><strong>校验和比较</strong>：OSS会将计算得到的校验和值与存储的校验和值进行比较。如果两个校验和值相匹配，则数据块被认为是完整和未损坏的；如果两个校验和值不匹配，则表示数据块可能已经损坏或发生了错误。</li></ol><p>通过以上方式，OSS能够计算和存储每个数据块的校验和，并在读取数据时验证校验和，以确保数据的完整性。校验和提供了一种简单而有效的机制，用于检测数据块是否被篡改或损坏。</p>]]></content>
    
    
    
    <tags>
      
      <tag>存储技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/01/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/01/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="三类题型"><a href="#三类题型" class="headerlink" title="三类题型"></a>三类题型</h1><ul><li>在有序数组中确定target是否存在</li><li>在有序数组中找&gt;&#x3D;target的最左位置</li><li>在有序数组中找&lt;&#x3D;target的最右位置</li></ul><h1 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h1><p>对于是否存在，只需要判断中间值是否等于target即可。而终止条件为left&gt;right。因为在相等的时候，也可能是符合条件的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestBinarySearch</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>N := <span class="hljs-number">100</span><br>V := <span class="hljs-number">1000</span><br>testTime := <span class="hljs-number">500000</span><br>fmt.Println(<span class="hljs-string">&quot;测试开始&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; testTime; i++ &#123;<br>n := rand.Intn(N)<br>nums := randomArray(n, V)<br>sort.Ints(nums)<br>target := rand.Intn(V)<br>a1 := normalRight(nums, target)<br>a2 := binarySearch(nums, target)<br><span class="hljs-keyword">if</span> a1 != a2 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;出错了!, a1=%v, a2=%v, nums=%v, target=%d\n&quot;</span>, a1, a2, nums, target)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;测试结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomArray</span><span class="hljs-params">(n, v <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>arr[i] = rand.Intn(v) + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">normalRight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> _, cur := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> cur == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// binarySearch 二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid := (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="在有序数组中找-target的最左位置"><a href="#在有序数组中找-target的最左位置" class="headerlink" title="在有序数组中找&gt;&#x3D;target的最左位置"></a>在有序数组中找&gt;&#x3D;target的最左位置</h1><p>寻找&gt;&#x3D;target的最左位置，步骤如下：</p><ul><li>如果<code>nums[mid]&gt;=target</code><ul><li>这是一个可能的值，需要暂时记下来</li><li>同时继续往左边看看还有没有其他的可能值</li></ul></li><li>否则<ul><li>直接向右看即可</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TestFindLeft 有序数组寻找&gt;=target的最左位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFindLeft</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>N := <span class="hljs-number">100</span><br>V := <span class="hljs-number">1000</span><br>testTime := <span class="hljs-number">500000</span><br>fmt.Println(<span class="hljs-string">&quot;测试开始&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; testTime; i++ &#123;<br>n := rand.Intn(N)<br>arr := randomArray(n, V)<br>sort.Ints(arr)<br>num := rand.Intn(V)<br>a1 := normalFindLeft(arr, num)<br>a2 := findLeft(arr, num)<br><span class="hljs-keyword">if</span> a1 != a2 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;出错了!, a1=%v, a2=%v, arr=%v, num=%d\n&quot;</span>, a1, a2, arr, num)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;测试结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">normalFindLeft</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> idx, cur := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> cur &gt;= target &#123;<br><span class="hljs-keyword">return</span> idx<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// findLeft 寻找有序数组第一个大于等于target的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLeft</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> res = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid := (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>res = mid       <span class="hljs-comment">// 这是一个可能的值</span><br>right = mid - <span class="hljs-number">1</span> <span class="hljs-comment">// 但是还要向左看下</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="在有序数组中找"><a href="#在有序数组中找" class="headerlink" title="在有序数组中找&lt;&#x3D;target的最右位置"></a>在有序数组中找&lt;&#x3D;target的最右位置</h1><p>寻找&lt;&#x3D;target的最左位置，步骤如下：</p><ul><li>如果<code>nums[mid]&lt;=target</code><ul><li>这是一个可能的值，需要暂时记下来</li><li>同时继续往右边看看还有没有其他的可能值</li></ul></li><li>否则<ul><li>直接向左看即可</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 有序数组寻找&lt;=num的最右位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFindRight</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>N := <span class="hljs-number">100</span><br>V := <span class="hljs-number">1000</span><br>testTime := <span class="hljs-number">500000</span><br>fmt.Println(<span class="hljs-string">&quot;测试开始&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; testTime; i++ &#123;<br>n := rand.Intn(N)<br>arr := randomArray(n, V)<br>sort.Ints(arr)<br>num := rand.Intn(V)<br>a1 := normalFindRight(arr, num)<br>a2 := findRight(arr, num)<br><span class="hljs-keyword">if</span> a1 != a2 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;出错了!, a1=%v, a2=%v, arr=%v, num=%d\n&quot;</span>, a1, a2, arr, num)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;测试结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">normalFindRight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> res = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> idx, cur := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">if</span> cur &gt; target &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res = idx<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// findLeft 寻找有序数组最后一个小于等于target的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRight</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>left := <span class="hljs-number">0</span><br>right := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> res = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid := (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &lt;= target &#123;<br>res = mid      <span class="hljs-comment">// 这是一个可能的值</span><br>left = mid + <span class="hljs-number">1</span> <span class="hljs-comment">//但是还是要继续向右看</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
